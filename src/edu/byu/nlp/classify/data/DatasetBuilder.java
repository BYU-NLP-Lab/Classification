/**
 * Copyright 2013 Brigham Young University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.byu.nlp.classify.data;

import java.util.Collection;
import java.util.List;

import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;

import edu.byu.nlp.classify.eval.BasicPrediction;
import edu.byu.nlp.classify.eval.Prediction;
import edu.byu.nlp.data.types.Dataset;
import edu.byu.nlp.data.types.DatasetInstance;
import edu.byu.nlp.dataset.BasicDataset;
import edu.byu.nlp.dataset.BasicDatasetInstance;
import edu.byu.nlp.dataset.Datasets;
import edu.byu.nlp.util.Nullable;

/**
 * A class that reduces a multiply-annotated dataset to a singly-labeled dataset
 * using a {@code LabelChooser} to decide which label to use when there are more than one
 * annotations.
 * 
 * Currently this class strips all pre-existing labels (concealed or observed). 
 * They are replaced with observed labels generated by the labelChooser based on annotation 
 * evidence. Instances without annotations are given no label. 
 * 
 * pfelt: this feels very similar to the data transforms facilitated by pipes in 
 * the dataset-utils project. Is there a way of using that to simplify this code?  
 */
public class DatasetBuilder {
    
    private final LabelChooser labelChooser;
    
      public DatasetBuilder(LabelChooser labelChooser) {
          this.labelChooser = labelChooser;
      }

      /**
       * @param data A dataset that may have been (multiply) annotated.
       * @param labeledPredictions A secondary return value. If this list is non-null, 
       * 	it is populated with the same values that make up the labeled portion of the returned dataset.
       * 
       * @return a dataset where multiple annotations have been combined into a single label.
       * measurements are unchanged.
       */
      public Dataset buildDataset(
              Dataset data,
              @Nullable Collection<Prediction> labeledPredictions) {
        Preconditions.checkNotNull(data);
        
          List<DatasetInstance> instances = Lists.newArrayList();
          
          // Split into labeled and unlabeled
          for (DatasetInstance instance : data) {
            List<Integer> rankedLabels = labelChooser.labelsFor(instance.getAnnotations().getLabelAnnotations()); 
            Integer bestLabel = (rankedLabels==null)? null: rankedLabels.get(0);
            
            instances.add(new BasicDatasetInstance(
                instance.asFeatureVector(), 
                bestLabel, false,  // observed label
                instance.getObservedRegressand(), false, // observed regressand 
                instance.getAnnotations(), instance.getInfo().getSource(), 
                instance.getInfo().getRawSource(), data.getInfo().getLabelIndexer()));
            
            if (bestLabel!=null && labeledPredictions != null) {
              labeledPredictions.add(new BasicPrediction(rankedLabels, instance));
            }
            
          }
          Preconditions.checkState(!instances.isEmpty(),"built an empty dataset!");
          Dataset newdataset = new BasicDataset(instances, data.getMeasurements(), Datasets.infoWithUpdatedCounts(instances, data.getInfo()));
          
          return newdataset;
    }
}
